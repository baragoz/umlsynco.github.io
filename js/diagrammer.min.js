/*
Class: DiagramElement, diagram, element and connector. dm.base.diagram implements inheritanse of methods.

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2012-13 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
 */


var dm = (function( window, undefined ) {

  var dm = {};
  dm.base = {};
  dm.menu = {};
  dm.ds = {};
  dm.cs = {};
  dm.hs = {};
  dm.dm = {};
  dm.ms = {ctx:{},ds:{}};

  dm.at = {cs:{created:null, selected:null}}; // Automated testing helpers

  return dm;
})(window);

window['dm'] = dm;

//export namespaces for minifier
dm['base'] = dm.base;
dm['menu'] = dm.menu;
dm['ds'] = dm.ds;
dm['cs'] = dm.cs;
dm['es'] = dm.es;
dm['hs'] = dm.hs;
dm['dm'] = dm.dm;
dm['ms'] = dm.ms;
dm['ms']['ctx'] = dm.ms.ctx;
dm['at'] = dm.at; //automated testing



//@aspect
(function( $, dm, undefined ) {

  // Function to remove tags
  dm.base.convert = function(str) {
      var c = {'<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#039;',
       '#':'&#035;' };
      return str.replace( /[<>'"#]/g, function(s) {
         return c[s]; 
      } );
  };

  //@export:dm.base.diagram:plain
  dm.base.diagram = function( name, base, prototype ) {
    var ns = name.split( "." ),
    fullName = ns[0] + "-" + ns[1],
    fullPath = "dm."+name;
    namespace = ns[ 0 ],
    name = ns[ 1 ];

    if ( !prototype ) {
      prototype = base;
      base = dm.base.DiagramElement;
    }

    dm = dm || {};
    dm [ namespace ] = dm [ namespace ] || {};
    dm [ namespace ][ name ] = function( options, parrent ) {
      // allow instantiation without initializing for simple inheritance
      if ( arguments.length ) {
        options = options || {};
        if (options['type'] == undefined)
          options['type'] = name;
        this._createDiagram( options, parrent);
      }
    };

    var basePrototype = new base();

    // TODO: the same options cloning happen in _CreateDiagram method
    var tmp_opt = $.extend( true, {}, basePrototype.options );
    basePrototype.options = tmp_opt;

    dm [ namespace ][ name ].prototype = $.extend( true, {}, basePrototype, {
      'namespace': namespace,
      diagramName: name,
      diagramEventPrefix: dm[ namespace ][ name ].prototype.diagramEventPrefix || name,
      'diagramBaseClass': fullPath,
      inherited: base.prototype.diagramBaseClass
    }, prototype );
  };
  //@print

  dm.base.DiagramElement = function( options, parent) {
    // allow instantiation without initializing for simple inheritance
    if ( arguments.length ) {
      this._createDiagram( options, parent);
    }
  } ;

  //@export:dm.base.DiagramElement:plain
  dm.base.DiagramElement.prototype = {
                                      'options': {
    'editable': true,
    'nameTemplate': 'base'
  },
  diagramBaseClass: 'dm.base.DiagramElement',
  _createDiagram: function( options, parent) {
    // extend the basic options
    var tmp_opt = $.extend(true, {}, this.options, options);
    this.options = tmp_opt;
    //this._setOptions(options); // Extended class could re-define some options setup

    //@proexp
    this.parrent = parent;
    //@proexp
    this.euid = this.options['type'] + dm.ds.diagram.ec;

    if (this.options['name'] == undefined) {
      this.options['name'] = this.options['nameTemplate'] + dm.ds.diagram.ec;
    }
    dm.ds.diagram.ec++;

    // it is responsible for this.element instance creation 
    this['_create']();

    //@overwrite
    this.element = $(this.element);

    if (this.element) {
      // element unique id
      $(this.element).data(this.euid, this );
      this._baseinit();

      var self = this;
      $(this.element).bind("remove." + this.euid, self, function(event) {
        event.data.destroy();
      });

      this['_init']();
    } else {
      // TODO: change on even to ERROR manager !!!
      alert("Please, declare method _create() for diagram element " + this.euid);
    }
  },

  
  getDescription: function(key, value) {
    var kv = !(key || value || false);
    var proto = Object.getPrototypeOf(this);
    var item = '{',
    comma = '';
    this._update();
    for (var i in this.options) {
      if (this.options[i] != undefined) {
        if (proto.options[i] != undefined) {
          if ((proto.options[i] != this.options[i]) || (i == 'type')) {
            item += comma + '"' + i + '":"' + this.options[i] + '"';
            comma = ',\n';
          }
        } else {
          var obj = this.options[i];
          if (obj instanceof Array) {
            var c = '';
            item += comma + '"' + i + '":[';
            comma = ',';
            for (var j in obj) {
              // Do not add element if it is not selected
              if (kv || (obj[j].option(key) == value)) {
                if (obj[j] && obj[j].getDescription) {
                  item += c + obj[j].getDescription();
                } else {
                  //item += c + '{"' + j + '":"' + obj[j] + '"}';
                  item += c + '"' +obj[j] + '"';
                }
                c = ',';
              }
            }
            item += ']\n';
          } else {
            if (typeof(obj) != 'object') {
              item += comma + '"' + i + '":"' + obj + '"';
              comma = ',\n';
            }
          }
        }
      } // this.options[i] != undefined
    }
    item += '}';
    return item;
  },
  
  _update: function() {
    $.log("_update");
  },
    
  
  _create: function(){$.log("_create");},
  
  _init: function(){$.log("_init");},
  
  _baseinit: function(){$.log("_baseinit");},

  
  _destroy: function(){$.log("_destroy");},
  destroy: function() {
    this['_destroy']();

    this.element
    .unbind( "." + this.euid )
    .removeData( this.euid );
  },
  
  option: function( key, value ) {
    var options = key;

    if ( arguments.length === 0 ) {
      // don't return a reference to the internal hash
      return $.extend( {}, this.options );
    }

    if  (typeof key === "string" ) {
      if ( value === undefined ) {
        return this.options[ key ];
      }
      options = {};
      options[ key ] = value;
    }

    this._setOptions( options );

    return this;
  },
  
  _setOptions: function( options ) {
    var self = this;
    for (var r in options) {
      self._setOption( r, options[r] );
    }
  },
  
  _setOption: function( key, value ) {
    this.options[ key ] = value;
    // TODO: REDIRECT ON inherited function !!!
  }
  /*
    
    _trigger: function( type, event, data ) {
        var callback = this.options[type];

        event = $.Event( event );
        event.type = ( type === this.diagramEventPrefix ?
                type :
                    this.diagramEventPrefix + type ).toLowerCase();
        data = data || {};

        // copy original event properties over to the new event
        // this would happen if we could call $.event.fix instead of $.Event
        // but we don't have a way to force an event to be fixed multiple times
        if ( event.originalEvent ) {
            for ( var i = $['event']['props']['length'], prop; i; ) {
                prop = $['event']['props'][ --i ];
                event[ prop ] = event['originalEvent'][ prop ];
            }
        }

        $(this.element).trigger( event, data );

        return !( $.isFunction(callback) &&
                callback['call']( this.element[0], event, data ) === false ||
                event['isDefaultPrevented']() );
    }*/ // I have no idea what is this stuff for ... 
  };

  //@print

  /**
   * jQuery.dm.base.diagram class.
   * The base class for all diagrams types. It is consist of base div which has
   * canvas, element and connector childs.
   * Options could be overwritten via heritage mehanizm - dm.base.diagram or
   * on diagram creation or via JSON description which provided as argument of
   * constructor
   * \jsonDesc - JSON description of diagram. It could consist of diagram
   *             specific desciption and elements and connectors JSON
   * \parrent  - The parrent element reference, which diagram should be
   *             attached
   */
  //@export:dm.ds.diagram
  dm.base.diagram("ds.diagram", {   
    'options': {
    'nameTemplate': 'diagram',
    'type2': 'diagram', // hack while we do not have a project manager
    'editable':true
  },
  
  _create: function () {
    //<div class="us-canvas-bg" style="width:' + this.options['width'] + 'px;height:' + this.options['height'] + 'px">
    //this.options.multicanvas = true; ~ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! USES for DROP SOME NODES FROM DYNATREE
    if (this.options.multicanvas) {
	  this.canvasEuid = this.euid +'_Canvas';
      this.element = $(this.parrent).append('<div id="' + this.euid + '" class="us-diagram" width="100%" height="100%">\
          <canvas id="' + this.euid +'_Canvas" class="us-canvas" width=' + this.options['width'] + 'px height=' + this.options['height'] + 'px>\
          <p>Unfortunately your browser doesn\'t support canvas.</p></canvas>\
          <div class="us-canvas-bg" style="width:100%;height:100%;">\
          </div></div>');
    } else {
      this.element = $(this.parrent).append('<div id="' + this.euid + '" class="us-diagram" width="100%" height="100%">\
          <div class="us-canvas-bg" style="width:100%;height:100%;">\
          </div></div>');
		  this.canvasEuid = 'SingleCanvas';
    }
    this.canvas = window.document.getElementById(this.canvasEuid);
    this.max_zindex = 100;

    // Diagram canvas drop element
    // It is not necessary for regular usage
    // TODO: make it as a separate functionality which glue 
    //       file tree and diagram engine

    var iDiagram = this;

    $("#" + this.euid + ".us-diagram").scroll(function() {iDiagram.draw();});
    /** Canvas extra functionality handling:
     *   1. Hide resize GUI helpers on canvas click
     *   2. Position locator is debug functionality
     *   3. Mouse Up/Down for connector stransforms perform
     */
    var diag = this;
    $("#" + this.euid)
    .dblclick(function(e) {
      e.preventDefault();
      $.log("DBL CLICK");         
      e.stopPropagation();
    })
    .click(function(evt) {
      $.log("clicked");
      // it could be undefined !!!
      //$("#tabs #us-editable").hide();
      diag._setWidgetsOption("selected", false);
      
      // Work-around for references
      $("#" + diag.euid + " .us-references").hide();
      /*            
           // Hide elements selectors on click
           //$(".ui-resizable-handle").css({'visibility':'hidden'});

           // Hack to notify about click
           //if (diag.clickedconntector) {
             diag.clickedconntector.selected = false;
           }

           if (diag.selectedconntector) {
             if (diag.clickedconntector != diag.selectedconntector) {
               diag.clickedconntector = diag.selectedconntector;
             }

             diag.selectedconntector.selected = true;

             if (diag.selectedconntector._showMenu)
               diag.selectedconntector._showMenu(x, y, true, diag.selectedconntector);
           } else {
             diag.clickedconntector = undefined;
           }
           this.selectedElement = undefined;
       */
      diag.draw();
      evt.stopPropagation();
    })
    ;

    // create an empty lists for connectors and elements
    this.connectors = [];
    this.elements = [];

    this.removedConnectors = [];
    this.removedElements = [];

    // For all elements in JSON description try to create an element
    for (var i in this.options['elements']) {
      // How to get options which described in menu JSON ? 
      this.Element(this.options['elements'][i].type, this.options['elements'][i]);
    }

    // For all connectors in JSON description try to create a connector 
    for (var i in this.options['connectors']) {
      this.options['connectors'][i]['stored'] = true;
      this.Connector(this.options['connectors'][i]['type'], this.options['connectors'][i]);
      // TODO: find elements IDs and add connectors between elements
      //       How to handle use-case when connector created,
      //                               but element was not creat yet?
      // TODO: think about queued operations which could be loaded
      //       sequentially even if one should be loaded but another
      //       one already exists
    }

    // Perform function on diagram load completion
    dm['dm']['loader']['OnLoadComplete'](function() {
      for (var i in diag.elements) {
        var d = diag.elements[i].options['dropped'];
        if (d) {
          diag.elements[i]._dropped = {};
          for (var ii in d) {
            for (var iii in diag.elements) {
              if (diag.elements[iii].options['id'] == d[ii]) {
                var idd = diag.elements[iii].euid;
                diag.elements[i]._dropped[idd] = idd;
                break; // from the neares for
              }
            } // iii
          } // ii
        }
      } // i
    });
  },
  
  _init: function () {
    // It is necessary to init mouse over listener
    // to detect connections types
  },
  _destroy: function(){
    if (this.onDestroyObserver) {
      this.onDestroyObserver();
    }
  },
  onDestroy: function(func) {
    this.onDestroyObserver = func;
  },
  /**
   * \class Function.
   * Create an element with \eid and unique name.
   * Call element load if was not create.
   * \uid Unique element type ID which corresponding to JS class
   * \options Extra options which overwrite base class options 
   * \jsonDesc - JSON which could understand loaded element JS class
   *
   * Note: for now we use ElementLoaded callback method which doesn't
   *       required at all.
   *       TODO: provide ElementLoaded functionality as
   *             argument-function of loader.Element
   */
  
  Element: function (type, options, callback) {
    dm.ds.diagram.ec++;
    options = options || {};

    var self = this;
    self.max_zindex++;
    options["z-index"] = self.max_zindex; //options["z-index"] || ();
    options["ctx_menu"] = options["ctx_menu"] || "default"; //options["z-index"] || ();

    dm['dm']['loader']['Element'](type, options, this, function(obj) {
      if (obj != undefined)
        self.elements[obj.euid] = obj;
      if (callback)
        callback(obj);
    });
    return options.euid;
  },

  
  _setWidgetsOption: function( key, value ) {
    if (key == "selected") {
      this.multipleSelection = value;
      for (var i in this.elements) {
        this.elements[i]._setOption( key, value );
      }
      for (var i in this.connectors) {
        this.connectors[i]._setOption( key, value );
      }

      this.selectedElement = undefined;
      this.selectedConnector = undefined;

    }
    else if (key == "z-index") { // Z-index supported by elements only (not applicable for connectors)
      var newmax = this.max_zindex,
      min_z = undefined,
      max_z = undefined,
      min_not_selected_z = undefined;
      // Identify the minimal z-index in selection
      for (var i in this.elements) {
        var r = this.elements[i].option(key);
        if (this.elements[i].option("selected")) {
          min_z = ((min_z == undefined) || r<min_z) ? r : min_z;
          max_z = ((max_z == undefined) || r>max_z) ? r : max_z;
        } else
          min_not_selected_z = ((min_not_selected_z == undefined) || r<min_not_selected_z) ? r : min_not_selected_z;
      }

      if ((min_not_selected_z == undefined) || (min_z == undefined))
        return; // all or nothing selected; nothing to relocate;

      $.log("Min Z-INDEX: " + min_z);
      var flag = (value == "front") ? true : false;
      for (var i in this.elements)
        if (this.elements[i].option("selected")) {
          if (flag) {
            var zi = this.elements[i].option(key) + this.max_zindex - min_z + 1;
            $.log("new Z-INDEX: " + zi + " D: " + this.elements[i].option(key));
            this.elements[i]._setOption( key, zi);
            if (zi >  newmax)
              newmax= zi;
          }
        } else {
          if (!flag) {
            var zi = this.elements[i].option(key) - min_not_selected_z + max_z + 1;
            $.log("new2 Z-INDEX: " + zi + " D: " + this.elements[i].option(key));
            this.elements[i]._setOption( key, zi);
            if (zi >  newmax)
              newmax= zi;
          }
        }
      this.max_zindex = newmax + 1;
    }
    else {
      var isSel = ("selected" != key);
      for (var i in this.elements)
        if (this.elements[i].option("selected")) {
          var opb = {},
          opa = {};
          opb[key] = this.elements[i].options[key];
          opa[key] = value;
          this.elements[i]._setOption( key, value );
        }
      for (var i in this.connectors)
        if (this.connectors[i].option("selected")) {
          opb[key] = this.connectors[i].options[key];
          opa[key] = value;
        }
    }

    this.draw(); // work-around to re-draw connectors after options update
  },
    
  /**
   * \class Function.
   * TODO: think about lifeline diagram
   */

  /**
   * \class Function.
   * Load and create a connector instance.
   * TODO: Why we do not use clallback method in that case ?
   *       How to load connector correctly ? 
   *       
   */
  
  Connector: function (type, options, callback) {
    // Loader is responsible for connector creation
    var self = this;

    dm['dm']['loader']['Connector'](type, options, this, function(connector) {
      if (connector != undefined) {
        self.connectors[connector.euid] = connector;
        if (connector.options.toId != 'ConnectionHelper') {
          $.log("REPORT: " + connector.options.toId + "   FROM : " + connector.options.fromId);
        }

        self.draw();
        if (callback)
          callback(connector);
      }
    });
  },


  /**
   * \class Function.
   * Clear the canvas rectangle and re-draw
   * all connectors on the Canvas.
   */
  
  draw: function() {
    if (!this.canvas)
      return;
    var ctx = this.canvas.getContext("2d");

    ctx.fillStyle = "#EEEEEE";//"rgba(140,140,140,1)";
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    if (Object.keys(this.connectors).length > 0) {
//    ctx.strokeRect(0, 0, 1000, 500);


      for (var c in this.connectors) {
        ctx.lineWidth = 1;

        if (this.connectors[c].options['linewidth'] != undefined) {
          ctx.lineWidth = this.connectors[c].options['linewidth'];          
        }

        if (this.connectors[c].options['selected']) {
          ctx.lineWidth += 2;
          this.connectors[c].redraw(ctx, "#43EC28");
          ctx.lineWidth -= 2;
          this.connectors[c].redraw(ctx);
        }
        else if (this.selectedconntector == this.connectors[c]) {
          this.connectors[c].redraw(ctx, "#43EC28");

        }
        else {
          if (this.connectors[c].options['color'])
            this.connectors[c].redraw(ctx, this.connectors[c].options['color']);
          else 
            this.connectors[c].redraw(ctx);
        }
      }
      ctx.lineWidth = 1;
    }
  },
  /**
   * \class Function.
   * Check that point is on the line.
   * It is necessary to hightlight connectors on mouseover
   * and it seems that capability of browser is good enought
   * to support such actions
   */
  
  isPointOnLine: function(x,y) {
    if (Object.keys(this.connectors).length > 0) {
      if (this.transformStarted == true) {
        this.selectedconntector.TransformTo(x,y);
        this.draw();
        return true;
      }
      for (var c in this.connectors) {        
        if (this.connectors[c].isPointOnLine(x,y)) {
          if (this.connectors[c] != this.selectedconntector) {
            this.selectedconntector = this.connectors[c];
            this.draw();
          }
          return true;
        }
      }
    }

    // Hide selected connector
    // because it is no longer highlited
    if (this.selectedconntector != undefined) {
      if (this.selectedconntector._showMenu != undefined) {
        this.selectedconntector._showMenu(x,y, false);
      }
      this.selectedconntector = undefined;
      dm.at.cs.mouseover = null;
      this.draw();
    }

    return false;
  }
  });


//  Global elements counter
//  Entroduced to avoid side-effecst because of
//  incorrectly implemented jquery requests
//  @export:dm.es.element
    dm.base.diagram("es.element", {
      'options': {
      'drop': false,
      'nameTemplate': 'Element',
      'width': 140,
      'height': 200,
      'left': 140,
      'top': 200,
      'selected': false,
      'area': "none",
      'ctx_menu':"default",
      'editable':true
    },
    /*
    destroy: function() {
      var el = this.parrent.elements;
      for (k in el) {
        if (el[k] == this) {
          delete el[k];
          el.splice(k, 1);
          break;
        }
      }
    },*/
    
    _create: function () {
      // if parent element is undefined, do nothing
      // create element at possition which described in jsonDesc
      alert("Could not create virtual element !!!");
    },
   
    _update: function() {
      var p = $("#" + this.euid + "_Border").position();
      this.options['pageX'] = p.left;
      this.options['pageY'] = p.top;
      this.options['left'] = p.left;
      this.options['top'] = p.top;
      this.options['width'] = $("#" + this.euid + "_Border").width();
      this.options['height'] = $("#" + this.euid + "_Border").height();

      if (this._dropped) {
        this.options['dropped'] = new Array();
        for (var i in this._dropped) {
          if (this.parrent.elements[i]) {
            this.options['dropped'].push(this.parrent.elements[i].options['id']);
          }
          else alert("NOTE FOUND: " + i);
        }
      }
    },

    
    _init: function () {
      if (this.options['height']) {
        $('#' + this.euid)
        .css('width', this.options['width']).css('height', this.options['height']);
        $('#' + this.euid + "_Border").css("width", this.options['width']);
      }

      if (this.options['top'])
        $('#' + this.euid)
        .css('top', this.options['top']);
    },

    /**
     * \class Function.
     *  Initialization of base operations of element:
     *  Wrap with boarder-div, add resizable handlers, css etc
     *  Add the behaviour: editable, draggale, menu hide/show
     *  TODO: refactoring is coming 
     */
    
    _baseinit: function() {
      //wrap with border
      var poz = "";
      if ((this.options['pageX'] != undefined)
          && (this.options['pageY'] != undefined)) {
        poz = " style='top:" +this.options['pageY'] + "px;left:" + this.options['pageX'] + "px;' ";
      }

      $(this.element).wrap('<div id="' + this.euid + '_Border"' + poz + ' class="us-element-border"></div>');
      var parrentClass = this.parrent;
      var self = this;
      self.highlighted = false;
      this.refN = 0;
      this.options.references = this.options.references || new Array();

      var subDiagramPaths = self.options['subdiagrams'] || self.options['references'] || {};
      var subDiagramRefs =  "<div class='us-references us-list'><ul class='context-menu-3'>";
      subDiagramRefs+="</ul></div>";
      
      var axis111 = this.options['axis'] || false;
      var elmt = $('#' + this.euid  + '_Border')
      .css({'position':'absolute'})
      .css('top', this.options['pageY'])
      .css('left', this.options['pageX']);

      // Hide element resize points which was
      // added on the previous step
      $('#' + this.euid +'_Border ' + ".ui-resizable-handle").css({'visibility':'hidden'});

      // You need to select element to start DND
      $('#'+this.euid)
      .click(self,function(event) {
        // Hide previous references
         $("#" + element.parrent.euid + " .us-references").hide();
      })       
      .mouseenter(self, function (event){
        var element = event.data;
        if (!element.options.selected && !element.highlighted) {
          element.highlighted = true;
          var $bw = $('#' + this.id +'_Border').css({'border-width':'3px'});
          var bw = $bw.css('border-left-width');
          $bw.css({left:'-=' + bw, top:'-='+bw});
        }
        if (element.euid == "package24" || element.euid == "package58") {
            var llllllll = element.options.references;
            var gggggggg = llllllll.length;
            ++gggggggg;
        }

        // Show "REFERENCE" in editable mode only
        if (element.options.references.length != 0) {

          var isShown = $("#" + element.euid + " .us-references").css('display') == "none";

          // Hide all references on diagram
          $("#" + element.parrent.euid + " .us-references").hide();

          // open item if it was closed
          if (!isShown) {
            var pos = $(this).position();
            $('#' + element.euid  + '_Border .us-references')
            .show()
            .css({top:pos.top+20, left:pos.left});
          }
        }
        //$(".elmenu-" + self.menutype).stop().animate({opacity:"1"});;
      })
      .mouseleave(self, function (event){
        var element = event.data;
        if (!element.options.selected && element.highlighted) {
          var $bw = $('#' + this.id +'_Border');
          var bw = $bw.css('border-left-width');
          $bw.css({'border-width':'0px'}).css({left:'+=' + bw, top:'+='+bw});
          element.highlighted = false;
        }
        $("#" + element.parrent.euid + " .us-references").hide();

      })
      .parent()
      .append(subDiagramRefs);

      for (var g in subDiagramPaths) {
         self.addReference({text:subDiagramPaths[g]}, true);
      }

      // Hide references by default and
      // prevent propagation of click event
      $('#' + this.euid  + '_Border .us-references')
      .hide()
      .click(function(e) {
        e.stopPropagation();
      });

/*
      $('#' + this.euid  + '_Border .us-references ul li a').bind("click", self, function(event) {
        var element = event.data;
        if (!element.parrent.options.editable) {
          dm.dm.fw.loadContent2(element.parrent.parrent, $(this).text());
        }
      });

*/
      //if (this.options['subdiagram'])
       {
        $("img#" + this.euid + "_REF")
		.attr('title', this.options['subdiagrams'])
		.click(self, function(event) {
          var element = event.data;
          var isShown = $("#" + element.euid + " .us-references").css('display') == "none";

          // Hide all references on diagram
          $("#" + element.parrent.euid + " .us-references").hide();

          // open item if it was closed
          if (!isShown) {
            var pos = $(this).position();
            $('#' + element.euid  + '_Border .us-references')
            .show()
            .css({top:pos.top+20, left:pos.left});
          }
          event.stopPropagation();
        });
      }

      if (this.options['color']) 
        this._setOption("color", this.options['color']);

      if (this.options['borderwidth'])
        this._setOption("borderwidth", this.options['borderwidth']);

      if (this.options["font-family"])
        this._setOption("font-family", this.options["font-family"]);

      if (this.options["z-index"])
        $('#'+this.euid + "_Border").css("z-index", this.options["z-index"]);
    },
  
    'addReference': function(opt, isInit) {
      var self = this;
      
      var old_attr;
      {
        old_attr = 'reference-'+this.refN;
        ++this.refN;

        // Do not update references on initialization
        if (!isInit)
        self.options.references.push(opt.text);
      }

       var idx = (opt.idx == undefined) ? this.refN : opt.idx,
         $ch =
         $("<li id='reference'><a id='"+old_attr+"' class='editablefield reference'>" + opt.text + "</a></li>"),
           $idx = $("#"+self.euid+"_Border .us-references ul li:eq(" + idx + ")");

         // if the position for insertion was found
         if ($idx.length == 1) {
           $ch = $ch.insertAfter($idx);
         }
         else {
           $ch = $ch.appendTo("#" + self.euid + "_Border div.us-references ul");
         }
         $ch = $ch.children("A.reference")
            .bind("click", self, function(event) {
              var element = event.data;
              dm.dm.fw.loadContent2(element.parrent.parrent, $(this).text());
              event.stopPropagation();
            })
            .bind("mouseenter", self, function(event) {
                $(this).parent().parent().parent().show();
            });


    },
    _setOption: function( key, value ) {
      var old_val  = this.options[ key ];

      if (this._setOption2 != undefined && this._setOption2(key, value)) {
        // redefine the base options in inherited class
      }
       else if (key == "font-color") {
        $("#" + this.euid + "_Border.us-element-border a").css("color", value);
      } else if (key == "left") {
        $("#" + this.euid + "_Border").css(key, value);
      } else if (key == "top") {
        $("#" + this.euid + "_Border").css(key, value);
      } else if (key == "color") {
        $("#" + this.euid).css("background-color", value || "");
      } else if (key == "borderwidth") {
        $("#" + this.euid).css("border-width", value || "");
      } else if (key == "width") {
        $("#" + this.euid + "_Border").css("width", value);
      } else if (key == "height") {
        $("#" + this.euid + "_Border").css("height", value);
        if (old_val && value != old_val) {
          var v = parseInt(value) - parseInt(old_val);
          var inc=(v>0)? ("+=" + v) : ("-=" + Math.abs(v));
          if (v != 0)
            $("#" + this.euid + "_Border .us-element-resizable-area").css("height", inc);
        }
      } else if (key == "font-family") {
        $("#" + this.euid).css(key, value || "");
      } else if (key == "selected") {
        if (value) {
          $('#' + this.euid +'_Border ' + ".ui-resizable-handle").css({'visibility':'visible'});
          if (!this.highlighted) {
            var $bw = $('#' + this.euid +'_Border').css({'border-width':'3px'});
            var bw = $bw.css('border-left-width');
            $bw.css({left:'-=' + bw, top:'-='+bw});
            this.highlighted = true;
          }
        }
        else {
          $('#' + this.euid +'_Border ' + ".ui-resizable-handle").css({'visibility':'hidden'});
          if (this.highlighted) {
            var $bw = $('#' + this.euid +'_Border');
            var bw = $bw.css('border-left-width');
            $bw.css({'border-width':'0px'}).css({left:'+=' + bw, top:'+='+bw});
          }
          this.highlighted = false;
        }
      } else if (key == "z-index") {
        $("#" + this.euid + '_Border ').css(key, value|| "");
      }
      this.options[ key ] = value;
    }
    });

    

    dm.ds.diagram = dm.ds.diagram || {}; 
    dm.ds.diagram.ec = 0; 

//  @export:dm.cs.connector
    dm.base.diagram("cs.connector", {
      'options': {
      'selected': false,
      'nameTemplate': 'Connector',
      'ctx_menu': 'connector'
    },
    
    addLabel: function(opt) {
      var self = this,
      lid = opt.lid != undefined ? opt.lid : this.euid + "_l" + this.label_count;  // uniqie label name to simplify revert editable

      if (opt.lid == undefined) ++this.label_count;

      var $item = $("<div id='"+lid+"' class='editablefield' style='position:absolute;z-index:99999;background-color:white;'>" + opt.text + "</div>")
      .appendTo("#" + this.parrent.euid)
      .css("left", opt.left)
      .css("top", opt.top)
      .mouseenter(function() {self.options.selected = true;
      self.parrent.draw();
      for (var i in self.labels) 
        $(self.labels[i]).addClass("us-connector-hover")})
      .mouseleave(function (){self.options.selected = false;
        self.parrent.draw();
        for (var i in self.labels) 
          $(self.labels[i]).removeClass("us-connector-hover")});
    },
    _setOption: function( key, value ) {
      if (value == undefined) {
        delete this.options[ key ];
        return;
      }

      if (key == "epoints") {
        for (var i in value) {
          this.epoints[i][0] = value[i][0];
          this.epoints[i][1] = value[i][1];
        }
      } else if (key == "labels") {
        for (var i in value) {
          this.labels[i].css({left:value[i][0], top: value[i][1]});
        }       
      }
      else {
        this.options[ key ] = value;
      }
    },
    
    _create: function () {
      this.epoints = [];
      var self=this;
      if (this.options.epoints != undefined) {
        $.each(this.options.epoints, function(idx, item) {
            self.epoints[idx] = [];
            self.epoints[idx][0] = parseInt(item[0]);
            self.epoints[idx][1] = parseInt(item[1]);
        });
      }
      this.label_count = 0;
      this.cleanOnNextTransform = false;

      dm.at.cs.created = {euid: this.euid, from:this.options.fromId, to:this.options.toId};

      if (this.options['stored']) {
        for (var i in this.parrent.elements) {
//        alert("ELEMENT: " + this.parrent.elements[i].euid);
          if (this.parrent.elements[i].options['id'] == this.options['fromId']) {
            this['from'] = this.parrent.elements[i].euid;
          }
          if (this.parrent.elements[i].options['id'] == this.options['toId']) {
            this['toId'] = this.parrent.elements[i].euid;
          }
        }
        if (this.options['epoints']) {
          dm.debug = dm.debug || {};
          dm.debug[this.euid] = this.options['epoints'];
          this.epoints = new Array();
          for (var i in this.options['epoints']) {
            this.epoints[i] = {};
            this.epoints[i][0] = parseInt(this.options['epoints'][i][0], 10);
            this.epoints[i][1] = parseInt(this.options['epoints'][i][1], 10);
          }
        }
        this.options['fromId'] = this['from'];
        this.options['toId'] = this['toId'];
      }
      else {
        this['from'] = this.options['fromId'];
        this['toId'] = this.options['toId'];
      }
      this.labels = new Array();
      for (var i in this.options['labels']) {
        var l = this.options['labels'][i];
                this.addLabel({text:l.name, left:parseInt(l.x), top:parseInt(l.y)});
      }
    },
    
    _init: function () {
      // this.element.draggable().resizable().selectable().border()
    },
    
    _baseinit: function() {
      // TODO: add on mouse drag&drop
    },
    
    drawSelected: function(c, points, color) {
      c.beginPath();
      c.fillStyle = color;
      c.strokeStyle = color;

      c.moveTo(points[0][0], points[0][1]);
      for (var i=1; i<points.length; ++i) {
        c.lineTo(points[i][0], points[i][1]);
      }
      c.stroke();
      c.closePath();
    },
    
    draw: function(ctx, points, color) {},

    
    redraw: function(ctx, color) {
      var context = ctx;
      var col = color || "rgba(0,0,0,1)";
      if (ctx == undefined) {
        // TODO: identify context by this,parent
        return;
      }
      this.points = this['_getConnectionPoints'](this['from'], this['toId'], this.epoints);
      this.gip = [];
      for (var i=0;i<this.points.length-1;++i) {
        var dy = this.points[i][1] - this.points[i+1][1],
        dx = this.points[i][0] - this.points[i+1][0];
        this.gip[i] = Math.sqrt(dx*dx + dy*dy);
      }


      // !!! It looks like conflict of naming. Diagram has draw method too,
      //     But with different signature
      // !!!
      // ???
      // Is is problem
      // Why it is possible to re-define methods for elements
      // but not possible for connector
      // ???
      this['draw'](context, this.points, col);
    },

    
    _getRValue: function(x1, x2, w) {
      var diffx = x2-x1;
      if (diffx>0) {
        if (diffx > w)
          return x1 + w;
        return x2;
      }
      return x1;
    },
    
    isPointOnLine: function(x,y) {
      if (this.points == undefined)
        return false;

      // Check if mouse is near to some extra point ?
      for (var c=0; c<this.epoints.length; ++c) {
        if ((this.epoints[c][0] - 12 < x) && (this.epoints[c][0] + 12 > x)
            && (this.epoints[c][1] - 12 < y) && (this.epoints[c][1] + 12> y)) {
          dm.at.cs.mouseover = {euid:this.euid,idx:c};
          return true;
        }
      }

      for (var i=0;i<this.points.length-1;++i) {
        var dx1 = x - this.points[i][0],
        dy1 = y - this.points[i][1],
        dx = this.points[i+1][0] - x,
        dy = this.points[i+1][1] - y,
        gip1 = Math.sqrt(dx1*dx1 + dy1*dy1),
        gip = Math.sqrt(dx*dx + dy*dy);

        if (((gip1 + gip) - this.gip[i]) < 0.2 ) {
          dm.at.cs.mouseover = {euid:this.euid};
          return true;
        }
      }
      return false;          
    },
    canRemovePoint: function(p1,p2,rp) {
      if ((p1 == undefined)
          || (p2 == undefined)) {
        return false;
      }
      var dx = p1[0] - p2[0],
      dy = p1[1] - p2[1],
      dx1 = p1[0] - rp[0],
      dy1 = p1[1] - rp[1],
      dx2 = p2[0] - rp[0],
      dy2 = p2[1] - rp[1],
      gip1 = Math.sqrt(dx1*dx1 + dy1*dy1),
      gip2 = Math.sqrt(dx2*dx2 + dy2*dy2),
      gip = Math.sqrt(dx*dx + dy*dy);
      if (((gip1 + gip2) - gip) < 0.5)
        return true;
      return false;
    },
    _getConnectionPoints: function(fromId, toId, epoints) {

      var p1 = $('#'+ fromId).position();
      var p2 = $('#' + toId).position();
      if (p2 == null) {
        return;
      }
///////////////////////////////////////////    PERFORMANCE IMPROVMENT REQUIRED  !!!!!!!!! ///////////////////////////////////
///////////////////////////////////////////    Do not recalculate coordinates for all elements !!!!!!!!! ////////////////////
///////////////////////////////////////////    It is necessary for draggable and resizable elements only !!!!!!!!! //////////
      var p11 = $('#'+ fromId + "_Border").position();
      var p21 = $('#' + toId + "_Border").position();
      var scrollTop = $("#" + this.parrent.euid).scrollTop(),
      scrollLeft = $("#" + this.parrent.euid).scrollLeft();

      if ((epoints == undefined) || (epoints.length == 0)) {
        var x1 = this._getRValue(p1.left + p11.left, p2.left + p21.left, $('#'+ fromId).width()) ;
        var y1 = this._getRValue(p1.top + p11.top, p2.top + p21.top, $('#'+ fromId).height()) ;

        var x2 = this._getRValue(p2.left + p21.left, p1.left + p11.left, $('#' + toId).width());
        var y2 = this._getRValue(p2.top + p21.top, p1.top + p11.top,  $('#' + toId).height());

        var newpoints = [[x1 + scrollLeft,y1 + scrollTop], [x2 + scrollLeft,y2 + scrollTop]];

        return newpoints;
      }
      else {
        scrollTop = $("#" + this.parrent.euid).scrollTop();
        scrollLeft = $("#" + this.parrent.euid).scrollLeft();
        var lln = epoints.length -1;
        var x1 = this._getRValue(p1.left + p11.left, epoints[0][0] - scrollLeft, $('#'+ fromId).width()) + scrollLeft;
        var y1 = this._getRValue(p1.top + p11.top, epoints[0][1] - scrollTop, $('#'+ fromId).height()) + scrollTop;

        var x2 = this._getRValue(p2.left + p21.left, epoints[lln][0] - scrollLeft, $('#' + toId).width()) + scrollLeft;
        var y2 = this._getRValue(p2.top + p21.top, epoints[lln][1] - scrollTop, $('#' + toId).height()) + scrollTop;
        scrollTop = 0;//$("#" + this.parrent.euid).scrollTop();
        scrollLeft =0;//$("#" + this.parrent.euid).scrollLeft();


        /*
         var x1 = p1.left + p11.left;
         var y1 = p1.top + p11.top;
         var x2 = p2.left + p21.left;
         var y2 = p2.top + p21.top;
         */      
        var newpoints = [];
        newpoints[0] = [x1,y1];
        for (var i=1;i<=epoints.length;++i) {
          newpoints[i] = [epoints[i-1][0], epoints[i-1][1]];//epoints[i-1];
          newpoints[i][0] -= scrollLeft;
          newpoints[i][1] -= scrollTop;
        }
        newpoints[epoints.length + 1] = [x2,y2];
        return newpoints;
      }
    }
    });
})(jQuery, dm);
/**
  *  
  */
(function( $, dm, undefined ) {

dm.base.diagram("es.class", dm['es']['element'], {
    'options': {
        'nameTemplate': 'Class',
        'width': '150px',
        'height': 'auto'
    },
    '_getAux': function(aux) {
      var auxmap = [];
      auxmap["Class"] = "";
      auxmap["Interface"] = "interface";
      auxmap["Enumeration"] = "enum";
      auxmap["Primitive"] = "primitive";
      auxmap["ORM"] = "ORM";
      auxmap["ORMComponent"] = "ORMComponent";
      auxmap["Template"] = " ";
      auxmap[undefined] = "";

      return auxmap[aux] || aux;
    },
    'addOperation': function(opt) {
      if (this.options['aux'] == "Enumeration")
        return;
      var self = this;
      var idx = (opt.idx == undefined) ? this.opN : opt.idx;

      // Ctrl-Z/Y support
      var old_id;
       {
        old_id  = ('operation-'+this.opN);
        ++this.opN;
        this.options.operations.push(opt.text);
      }



       var $op = $('<li id="operation"><a id="'+old_id+'" class="editablefield operation" >' + opt.text + '</a></li>'),
           $idx = $("#" + this.euid + " .us-class-operations .us-sortable li:eq("+idx+")");
       
       // if index not found
       if ($idx.length == 1) {
         $op.insertAfter($idx);
       }
       else {
         $op.appendTo("#" + this.euid + " .us-class-operations .us-sortable");
       }

       $op = $op.children("a");

       var hg = $op
                 .height();

       dm.base.editable(this, $op, true);

       var h1 = $("#" + this.euid + " .us-class-operations .us-sortable").sortable("refresh").height(),
           h2 = $("#" + this.euid + " .us-class-operations").height(),
           h3, h4;
       if (h1 > h2 ) {
         h3 = $("#" + this.euid + "_Border").height();
         $("#" + this.euid + "_Border").height("+="+ hg);
         $("#" + this.euid + " .us-class-operations").height("+=" + hg);
         h4 = $("#" + this.euid + "_Border").height();
         this.options.height = h4;
         this.options.height_o += hg;
       }
    },
    'addAttribute': function(opt) {
       if (this.options['aux'] == "Interface")
         return;
       var self = this;
       var old_attr;
       {
         old_attr = 'attribute-'+this.atrN;
         ++this.atrN;
       }
       var idx = (opt.idx == undefined) ? this.opN : opt.idx;
       var $ch = $('<li id="attribute"><a id="'+ old_attr +'" class="editablefield attribute" >' + opt.text + '</a></li>'),
          $idx = $("#" + this.euid + " .us-class-attributes .us-sortable li:eq("+idx+")");
       
       // if index not found
       if ($idx.length == 1) {
         $ch = $ch.insertAfter($idx);
       }
       else {
         $ch = $ch.appendTo("#" + this.euid + " .us-class-attributes .us-sortable");
       }

       var hg = $ch.height();
       

       var h1 = $("#" + this.euid + " .us-class-attributes .us-sortable").sortable("refresh").height(),
           h2 = $("#" + this.euid + " .us-class-attributes").height(),
           h3, h4;

       if (h1 > h2) {
         h3 = $("#" + this.euid + "_Border .us-class-attributes").height();

         $("#" + this.euid + "_Border").height("+="+ hg);
         $("#" + this.euid + " .us-class-attributes").height("+=" + hg);

         h4 = $("#" + this.euid + "_Border .us-class-attributes").height();
         this.options.height_a = h4;
         this.options.height = $("#" + this.euid + "_Border").height();
       }
    },
    '_create': function() {
       var templ = "",
           aux = "";
       this.atrN = 0;
       this.opN = 0;

       // Work-around for get description methods
       this.options.operations = this.options.operations || new Array();
       this.options.attributes = this.options.attributes || new Array();

       if (this.options['aux'] && (this.options['aux'] != "")) {
           var aux2 = this._getAux(this.options['aux']);
           if (aux2 != undefined && aux2 != "" && aux2 != " ") {
             aux = "&lt&lt " + aux2 + " &gt&gt";
           }
           templ = (this.options['aux'] != 'Template') ? "" : "<div id='template' class='editablefield us-class-template'>" + (this.options['template'] || "T")+"</div>";
       }

       var operations = "",
           attributes = "";

        for (var i in this.options['operations']) {
           operations += '<li id="operation"><a id="operation-'+this.atrN+'" class="editablefield operation">' + this.options['operations'][i] + '</a></li>';
           this.atrN++;
        }
    
        for (var i in this.options['attributes']) {
           attributes += '<li id="attribute"><a id="attribute-'+this.opN+'" class="editablefield attribute">' + this.options['attributes'][i] +'</a></li>';
           this.opN++;
        }

      // HTML for class structure creation
      this.innerHtmlClassInfo = '\
        <div id="' + this.euid + '" class="us-class grElement">'+ templ+'\
        <div class="us-class-header">\
        <a id="name" class="editablefield us-class-name">' + this.options['name'] + '</a><br>\
        <a id="aux" class="us-class-aux">'+ aux +'</a>\
        </div>\
        <div class="us-class-attributes"><ul class="us-sortable">' +  attributes + '</ul></div>\
        <div class="us-class-operations us-element-resizable-area"><ul class="us-sortable">' +  operations + '</ul></div>\
        </div>\
      ';
      $("#" + this['parrent'].euid).append(this.innerHtmlClassInfo);
      
      this.element = $("#"  + this.euid);

    },
    '_init': function() {
        this._setOptions(this.options);
        this.attributes = new Array();
        this.operations = new Array();

       if (this['parrent'].options['editable']) {
      
         var border = "#"+this.euid + "_Border";
         var self = this;
         // stop-function is a fix for attributes area which became not resizizable with black points after internal resize usage
      }
    },
    _setOption2:function(key, value) {
      if (key == "height_o") {
        $('#' + this.euid  + '_Border .us-class-operations').css('height', value);
        return true;
      } else if (key == 'height_a') {
         var oval = this.options[key];
         $('#' + this.euid  + '_Border .us-class-attributes').css('height', value);

         var v = parseInt(value) - parseInt(oval);
         
         if (v != 0) {
           var inc=(v>0)? ("+=" + v) : ("-=" + Math.abs(v));

           $('#' + this.euid  + '_Border').css('height', inc);

           // Change the default height value too
           this.options['height'] += v;
        }

         return true;
      }
      else if (key == "editable") {
        // do not return true because it is only part of 
        // transition to none-editable
        $("#" + this.euid + " .us-sortable").sortable({ disabled: (value == true) ? false:true });
      }
      /* else if (key.indexOf('height') == 0) {
         var diff = parseInt(value) - parseInt(this.options['height_a']) - $('#' + this.euid + ' .us-class-header').height();
         if (diff > 0)
           $('#' + this.euid  + '_Border .us-class-operations').css('height', diff);
      }*/
      return false;
    },
    'ec': 0
});

})(jQuery, dm);
/*
Class: loader

Lazy load of diagrams, elements, connectors and it's menus:
// dm/ - diagram manager
// dm/ms - menus
// dm/ms/ctx - context menu
// dm/ms/ds - diagram's menu
// dm/ds - diagram classes folder
// dm/ds/diagram.js - base class for diagram, element and connector
// dm/ds/<type>.js - <type> of diagram class,package etc...
// dm/es/ - element classes folder
// dm/es/<type>.js - <type> of element image, class, artifact etc...
// dm/cs/<type>.js - <type> of connector aggragation, composition etc ...

// TBD:
// dm/ms/vp - main diagram load menu
// dm/hs/tabbed.js - tabs based diagram handler
// dm/hs/plain.js - handler to insert diagrams into the docuemnt (not implemented)

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
 */
//@aspect
(function($, dm, undefined) {

  // singleton object
  dm.dm.loader = dm.dm.loader || null; 

  //@export:dm.base.loader:plain 
  dm.base.loader = function(urlArg) {

    var createInstance = function() { 
      this.working = false;

      return {
        getUrl: function() {
        return urlArg;
      },
      _addToLoadQueue: function(item) {
        var instance = dm.dm['loader'];
        if (!instance._loadQueue) {
          instance.working = false;
          instance._loadQueue = new Array();
        }
        instance._loadQueue.push(item);
        instance._process(false);
      },
      _process: function(isAjaxCallback) {
        var item = null;
        var instance = dm.dm['loader'];
        if (instance.working) {
          return;
        }

        if ((isAjaxCallback && instance._loadQueue.length > 0) || (instance._loadQueue.length == 1 && !instance.working)) {
          instance.working = true;
          item = instance._loadQueue.shift();

        }

        if (item) {
          var callback = item.callback,
          data = item.data,
          self = instance;

          // Check that we still need to load data
          // It is possible that previous item 
          // loaded all necessary data yet.
          if (item.precondition()) {
            $.ajax({
              'url': urlArg + item.url,
              'dataType': "script",
              'success': function(){
              callback(data);
              self.working = false;
              self._process(true);
            },
            'error': function(){
              // Do not call calback on failed
              // callback(data);
              alert("Failed to load: " + urlArg + item.url);
              self.working = false;
              self._process(true);
            }
            });
          }
          else {
            callback(data);
            self.working = false;
            self._process(true); 
          }
        } else {
          instance.working = false;
        }
      },
      //@proexp
      'OnLoadComplete': function(callback2, options) {
        this._addToLoadQueue({
          url: "",
          precondition: function() { return false;},
          callback: function(opt) { if (callback2) callback2(opt);},
          data: options
        });
      },
      //@proexp
      'Diagram': function(dName, dType, options, parrent, argCallback) {

        if ((dm['ds'] == undefined)
            || (dm['ds']['diagram'] == undefined)) {
          // it is secure because LazyLoad deal with queue
          this._addToLoadQueue({
            url: "./dm/ds/diagram.js",
            precondition: function() {return true;},
            callback:function(data) {},
            data: null       
          });
        }

        var self = this;
        var opt = {},
        option = options || {};
        option['type'] = dName;
        option['base_type'] = dType;
        opt.options = options;
        opt.diagram = dName;
        opt.type = dType;
        opt.parrent = parrent;

        this._addToLoadQueue({
          url:"/dm/ds/" + dType + ".js",
          precondition: function() {
          if ((dm['ds'] == undefined)
              || (dm['ds'][dType] == undefined)) {
            return true;
          }
          return false;
        },
        callback: function(data) {
          var newdiagram = new dm['ds'][data.type](options, parrent);
          $.log("NAME: " + parrent);
          if (argCallback) {
            argCallback(newdiagram);
          }
          return newdiagram;
        },
        data: opt
        });

      },
      //@proexp
      'LoadElement': function(type) {

        if (dm['es'] == undefined) {
          alert("You should create diagram instance first !!!");
          return;
        }

        if (dm['es'][type] == undefined) {
          // start element loading, but do not allocate it
          this._addToLoadQueue({
            url: "/dm/es/" + type + ".js",
            precondition: function() {
            if (dm['es'][type] == undefined) {
              return true;
            }
            return false;
          },
          callback: function() {}
          });
        }
      },
      //@proexp
      'Element': function(type, options, diagram, callback2) {

        if (dm['es'] == undefined) {
          alert("You should create diagram instance first !!!");
          return;
        }

        var opt = {};
        opt.options = options;
        opt.type = type;
        opt.diagram = diagram;
        this._addToLoadQueue({
          url: "/dm/es/" + type + ".js",
          precondition: function() {
          if (dm['es'][type] == undefined) {
            return true;
          }
          return false;
        },
        callback: function(o) { 
          var e2 = new dm['es'][o.type](o.options, o.diagram);
          if (callback2)
            callback2(e2);
        },
        data:opt
        });
      },
      //@proexp
      'Connector': function(type, options, diagram, callback2) {

        if (dm.cs == undefined) {
          alert("You should create diagram instance first !!!");
          return;
        }

        var opt = {};
        opt.options = options;
        opt.type = type;
        opt.diagram = diagram;

        this._addToLoadQueue({
          url: "./dm/cs/" + type + ".js",
          precondition: function() {
          if (dm['cs'][type] == undefined) {
            return true;
          }
          return false;
        },
        callback: function(o) {
          var e2 = new dm['cs'][o.type](o.options, o.diagram);
          if (callback2 != undefined)
            callback2(e2);
        },
        data: opt});
      }
      }; 
    };

    var getInstance = function() { 
      if (!dm.dm['loader']) { 
        // create a instance 
        dm.dm['loader'] = new createInstance(); 
        dm.dm['loader']['url'] = urlArg; // Some reference in diagram's menu
        dm.dm['loader'].working = false;
      } 

      // return the instance of the singletonClass 
      return dm.dm['loader']; 
    }
    return getInstance(); 
  };
  //@print
  dm['base']['loader'] = dm.base.loader;
//@aspect
})(jQuery, dm);
/*
Class: aggregation

Aggregation connector creates a connection beween two elements of diagram

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
 */
//@aspect
(function($, dm, undefined) {

    dm.base.diagram("cs.aggregation", dm['cs']['connector'], {
        'draw': function(context2, points, color) {
        if ((points == null) || (points.length < 2)) {
            return;
        }

        var ep = points.length-1;
        var x = 10,
        dx = points[ep][0] - points[ep-1][0],
        dy = points[ep][1] - points[ep-1][1],
        gip = Math.sqrt(dx*dx + dy*dy);

        if (gip<x)
            return;

        var sina = dy/gip,
        cosa = dx/gip,
        x3 = points[ep][0] - Math.sqrt(x*x*3/4)*cosa,
        y3 = points[ep][1] - Math.sqrt(x*x*3/4)*sina,
        x6 = points[ep][0] - Math.sqrt(x*x*3)*cosa,
        y6 = points[ep][1] - Math.sqrt(x*x*3)*sina,
        x4 = x3 + x * sina/2,
        y4 = y3 - x * cosa/2,
        x5 = x3 - x * sina/2,
        y5 = y3 + x * cosa/2;

        context2.beginPath();
        context2.fillStyle = color;
        context2.strokeStyle = color;

        context2.moveTo(points[0][0], points[0][1]);
//        context2.arc(points[0][0], points[0][1], 3, 0, Math.PI * 2, true);
for (var i=1; i<ep; ++i) {
    context2.lineTo(points[i][0], points[i][1]);
//    context2.arc(points[i][0], points[i][1], 3, 0, Math.PI * 2, true);
}
context2.moveTo(points[ep-1][0], points[ep-1][1]);
context2.lineTo(x6, y6);
context2.lineTo(x4, y4);
context2.lineTo(points[ep][0], points[ep][1]);
context2.lineTo(x5, y5);
context2.lineTo(x6, y6);

context2.stroke();
context2.closePath();

    }
    });
//@aspect
})(jQuery, dm);
/*
Class:  nested

UML nested  connector creates a connection beween two elements of diagram

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
*/
//@aspect
(function($, dm, undefined) {

dm.base.diagram("cs.nested", dm.cs['connector'], {
    'draw': function(context2, points, color) {
            if ((points == null) || (points.length < 2)) {
               return;
            }

            var ep = points.length-1;
            var x = 15,
                dx = points[ep][0] - points[ep-1][0],
                dy = points[ep][1] - points[ep-1][1],
                gip = Math.sqrt(dx*dx + dy*dy);

            
            var sina = dy/gip,
            cosa = dx/gip,
            z = x-3,
            x3 = points[ep][0] - Math.sqrt(x*x*3/4)*cosa,
            y3 = points[ep][1] - Math.sqrt(x*x*3/4)*sina,
            x6 = points[ep][0] - Math.sqrt(x*x*3)*cosa,
            y6 = points[ep][1] - Math.sqrt(x*x*3)*sina,
            x4 = x3 + z * sina/2,
            y4 = y3 - z * cosa/2,
            x5 = x3 - z * sina/2,
            y5 = y3 + z * cosa/2,
            x31 = points[ep][0] - Math.sqrt(z*z*3/4)*cosa,
            y31 = points[ep][1] - Math.sqrt(z*z*3/4)*sina,
            x61 = points[ep][0] - Math.sqrt(z*z*3)*cosa,
            y61 = points[ep][1] - Math.sqrt(z*z*3)*sina;
            
            context2.beginPath();
            context2.fillStyle = color;
            context2.strokeStyle = color;
            context2.moveTo(points[0][0], points[0][1]);
            for (i=1; i<ep; ++i) {
              context2.lineTo(points[i][0], points[i][1]);
            }

            if (gip<x)
               return;

            context2.moveTo(points[ep-1][0], points[ep-1][1]);
            context2.lineTo(x6, y6);
            context2.stroke();
            context2.moveTo(x3, y3);
            context2.arc(x3,y3, x/2, 0, Math.PI * 2, true);
            
            context2.moveTo(x4, y4);
            context2.lineTo(x5, y5);
            
            context2.moveTo(x31, y31);
            context2.lineTo(x61, y61);
            //context2.lineTo(x6, y6);

            context2.stroke();
            context2.closePath();
        
    }
    });
//@aspect
})(jQuery, dm);
/*
Class: composition

UML composition connector creates a connection beween two elements of diagram

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
*/
//@aspect
(function($, dm, undefined) {

dm.base.diagram("cs.composition", dm.cs['connector'], {
    'draw': function(context2, points, color) {
            if ((points == null) || (points.length < 2)) {
               return;
            }

            var ep = points.length-1;
            var x = 10,
                dx = points[ep][0] - points[ep-1][0],
                dy = points[ep][1] - points[ep-1][1],
                gip = Math.sqrt(dx*dx + dy*dy);

            if (gip<x)
               return;
            
            var sina = dy/gip,
            cosa = dx/gip,
            x3 = points[ep][0] - Math.sqrt(x*x*3/4)*cosa,
            y3 = points[ep][1] - Math.sqrt(x*x*3/4)*sina,
            x6 = points[ep][0] - Math.sqrt(x*x*3)*cosa,
            y6 = points[ep][1] - Math.sqrt(x*x*3)*sina,
            x4 = x3 + x * sina/2,
            y4 = y3 - x * cosa/2,
            x5 = x3 - x * sina/2,
            y5 = y3 + x * cosa/2;
            context2.beginPath();
            context2.fillStyle = color;
            context2.strokeStyle = color;
            context2.moveTo(points[0][0], points[0][1]);
            for (i=1; i<ep; ++i) {
              context2.lineTo(points[i][0], points[i][1]);
            }
            context2.stroke();
            context2.closePath();

            context2.beginPath();
            context2.fillStyle = color;
            context2.strokeStyle = color;
            context2.moveTo(points[ep-1][0], points[ep-1][1]);
            context2.lineTo(x6, y6);
            context2.lineTo(x4, y4);
            context2.lineTo(points[ep][0], points[ep][1]);
            context2.lineTo(x5, y5);
            context2.lineTo(x6, y6);
            context2.fill();
            context2.stroke();
            context2.closePath();




            
    }
    });
//@aspect
})(jQuery, dm);
/*
Class: dependency

Dependency connector creates a connection beween two elements of diagram

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
*/
//@aspect
(function($, dm, undefined) {

dm.base.diagram("cs.dependency", dm.cs['connector'], {
    dashedLine: function(p1,p2, c) {
      var x2 = p2[0],
      x1 = p1[0],
      y2 = p2[1],
      y1 = p1[1];

      var x = 10, // dash length
      dashf = 5,
      dashe = 3,
      dx = x2 -x1,
      dy = y2 -y1,
      gip = Math.sqrt(dx*dx + dy*dy);

      if (gip<x) // Nothing to draw
         return;

      var sina = dy/gip,
      cosa = dx/gip,
      fx = dashf * cosa,
      fy = dashf * sina,
      ex = dashe * cosa,
      ey = dashe * sina;

      for (i=0; i<(gip/(dashf + dashe)); ++i) {
        c.moveTo(x1, y1);
        c.lineTo(x1+fx, y1+fy);
        x1+= (ex + fx);
        y1+= (ey + fy);
      }
    
    },
    'draw': function(c, points, color) {
            if ((points == null) || (points.length < 2)) {
               return;
            }
            var ep = points.length-1,
            x = 10;
            var x2 = points[ep][0],
            x1 = points[ep-1][0],
            y2 = points[ep][1],
            y1 = points[ep-1][1];

            var dx = x2 -x1,
                dy = y2 -y1,
                gip = Math.sqrt(dx*dx + dy*dy);

            var sina = dy/gip,
            cosa = dx/gip,
            x3 = x2 - Math.sqrt(x*x*3/4)*cosa,
            y3 = y2 - Math.sqrt(x*x*3/4)*sina,
            x6 = x1 - Math.sqrt(x*x*3)*cosa,
            y6 = y1 - Math.sqrt(x*x*3)*sina,
            x4 = x3 + x * sina/2,
            y4 = y3 - x * cosa/2,
            x5 = x3 - x * sina/2,
            y5 = y3 + x * cosa/2;
            
            c.beginPath();
            c.fillStyle = color;
            c.strokeStyle = color;
            for (var i=0; i<points.length-1; ++i) {
              this.dashedLine(points[i], points[i+1], c);
            }

            c.moveTo(x4, y4);
            c.lineTo(x2, y2);
            c.lineTo(x5, y5);
            c.stroke();
            c.closePath();            
    }
    });
//@aspect
})(jQuery, dm);
/*
Class: realization

Realization connector creates a connection beween two elements of diagram

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
*/
//@aspect
(function($, dm, undefined) {

dm.base.diagram("cs.realization", dm.cs['connector'], {
    dashedLine: function(p1,p2, c) {
      var x2 = p2[0],
      x1 = p1[0],
      y2 = p2[1],
      y1 = p1[1];

      var x = 10, // dash length
      dashf = 5,
      dashe = 3,
      dx = x2 -x1,
      dy = y2 -y1,
      gip = Math.sqrt(dx*dx + dy*dy);

      if (gip<x) // Nothing to draw
         return;

      var sina = dy/gip,
      cosa = dx/gip,
      fx = dashf * cosa,
      fy = dashf * sina,
      ex = dashe * cosa,
      ey = dashe * sina;

      for (i=0; i<(gip/(dashf + dashe)); ++i) {
        c.moveTo(x1, y1);
        c.lineTo(x1+fx, y1+fy);
        x1+= (ex + fx);
        y1+= (ey + fy);
      }
    
    },
    'draw': function(c, points, color) {
            if ((points == null) || (points.length < 2)) {
               return;
            }

            var ep = points.length-1;
            var x2 = points[ep][0],
            x1 = points[ep-1][0],
            y2 = points[ep][1],
            y1 = points[ep-1][1];

            var x = 10,
                dx = x2 -x1,
                dy = y2 -y1,
                gip = Math.sqrt(dx*dx + dy*dy);

            var sina = dy/gip,
            cosa = dx/gip,
            x3 = x2 - Math.sqrt(x*x*3/4)*cosa,
            y3 = y2 - Math.sqrt(x*x*3/4)*sina,
            x6 = x1 - Math.sqrt(x*x*3)*cosa,
            y6 = y1 - Math.sqrt(x*x*3)*sina,
            x4 = x3 + x * sina/2,
            y4 = y3 - x * cosa/2,
            x5 = x3 - x * sina/2,
            y5 = y3 + x * cosa/2;

            c.beginPath();
            c.fillStyle = color;
            c.strokeStyle = color;

            for (var i=0; i<points.length-1; ++i) {
              this.dashedLine(points[i], points[i+1], c);
            }
            if (gip<x) {
                 c.stroke();
              c.closePath();
              return;
            }

            c.moveTo(x3, y3);
            c.lineTo(x4, y4);
            c.lineTo(x2, y2);
            c.lineTo(x5, y5);
            c.lineTo(x3, y3);
            c.stroke();
            c.closePath();
    }
    });
//@aspect
})(jQuery, dm);
/*
 Class: base
        Base diagram type, most diagram doesn't requered any specific changes in the base structures
        that's why there is no needs to duplicate code
 Author:
   Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

 Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

 URL:
  umlsync.org/about

 Version:
  2.0.0 (2012-07-12)
*/
//@aspect
(function( $, dm, undefined ) {
    dm['base']['diagram']("ds.base", dm.ds['diagram'], {
        diagramName: "BaseDiagram",
        diagramEventPrefix: "CD",
        'options': {
            'width': 1300,
            'height': 700,
            'type': 'base'
        },
        '_init': function() {
        }
    });
//@aspect
})(jQuery, window.dm);
/*
Class: generalization

Generalization connector creates a connection beween two elements of diagram

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
*/
//@aspect
(function($, dm, undefined) {

dm.base.diagram("cs.generalization", dm.cs.connector, {
    'draw': function(c, points, color) {
            if ((points == null) || (points.length < 2)) {
               return;
            }

            var ep = points.length-1;
            var x2 = points[ep][0],
            x1 = points[ep-1][0],
            y2 = points[ep][1],
            y1 = points[ep-1][1];

            var x = 10,
                dx = x2 -x1,
                dy = y2 -y1,
                gip = Math.sqrt(dx*dx + dy*dy);

            if (gip<x)
               return;

            var sina = dy/gip,
            cosa = dx/gip,
            x3 = x2 - Math.sqrt(x*x*3/4)*cosa,
            y3 = y2 - Math.sqrt(x*x*3/4)*sina,
            x6 = x1 - Math.sqrt(x*x*3)*cosa,
            y6 = y1 - Math.sqrt(x*x*3)*sina,
            x4 = x3 + x * sina/2,
            y4 = y3 - x * cosa/2,
            x5 = x3 - x * sina/2,
            y5 = y3 + x * cosa/2;
            
            c.beginPath();
            c.fillStyle = color;
            c.strokeStyle = color;
            c.moveTo(points[0][0], points[0][1]);
            for (i=1; i<ep; ++i) {
              c.lineTo(points[i][0], points[i][1]);
            }
            c.moveTo(x1, y1);
            c.lineTo(x3, y3);
            c.lineTo(x4, y4);
            c.lineTo(x2, y2);
            c.lineTo(x5, y5);
            c.lineTo(x3, y3);
            c.stroke();
            c.closePath();            
    }
    });
//@aspect
})(jQuery, dm);
/**
  *  
  */
//@aspect
(function( $, dm, undefined ) {
dm.base.diagram("es.package", dm.es.element, {
    'options': {
        'nameTemplate': "Package",
        'droppable': true,
        'acceptdrop': "package",
        'height': "102px"
    },
    '_update': function() {
       var p = $("#" + this.euid + "_Border").position();
       this.options.pageX = p.left;
       this.options.pageY = p.top;
       this.options.left = p.left;
       this.options.top = p.top;
       this.options.width = $("#" + this.euid + "_Border").width();
       this.options.height = $("#" + this.euid + "_Border").height();

       // Height of packet body. Width is the same for all part of element
       this.options.height_b = $("#" + this.euid + "_Border .us-package-body").height();
       
       if (this._dropped) {
         this.options.dropped = new Array();
         for (i in this._dropped) {
           this.options.dropped.push(this.parrent.elements[this._dropped[i]].options.id);
         }
       }
    },
    '_create': function() {
      // HTML for class structure creation
      var aux = (this.options.aux != undefined) ? "<a>&lt&lt" + this.options.aux + "&gt&gt</a><br><b>" : "";
      this.innerHtml = '<div id="' + this.euid + '" class="us-package">\
                                <div class="us-package-tab grElement"></div>\
            <div class="us-package-body grElement">'
            + aux + 
            '<a id="name" class="editablefield">'+ this.options.name + '</a></div>\
                                </div>';
      $("#" + this.parrent.euid).append(this.innerHtml);
      this.element = $("#"  + this.euid);
    },
    '_init': function() {
	  this._setOptions(this.options);
    },
    '_setOption2': function( key, value ) {
		if (key == "color") {
            $("#" + this.euid + " .us-package-tab").css("background-color", value);
            $("#" + this.euid + " .us-package-body").css("background-color", value);
			return true;
        } else if (key == "borderwidth") {
            $("#" + this.euid + " .us-package-tab").css("border-width", value);
            $("#" + this.euid + " .us-package-body").css("border-width", value);
			return true;
        } else if (key == "font-family") {
          $("#" + this.euid).css(key, value);
		  return true;
        } if (key == "z-index") {
          $("#" + this.euid + '_Border ').css(key, value);
		  return true;
        }
        return false;
    }
});
//@aspect
})(jQuery, dm);
/**
  *  
  */
(function( $, dm, undefined ) {
})(jQuery, dm);

(function( $, dm, undefined ) {
dm.base.diagram("ds.sequence", dm.ds.base, {
});
}) ( jQuery, dm );
/**
  *  
  */
(function( $, undefined ) {
dm.base.diagram("es.objinstance", dm.es.element, {
	options: {
		nameTemplate: "Object",
	    acceptdrop: "package",
		top_min: 40,
		height: 400,
        resizable_h: 'e-u,e-ul,s-u,w-u,w-ul,sw-u,se-u',
		axis: 'x'
	},
	_create: function() {
	  // HTML for class structure creation
      this.innerHtml = '<div id="' + this.euid + '" class="us-element-resizable-area" style="width:100%;">\
                        <div class="us-instance-line"></div>\
	                    <div id="' + this.euid + '_NEXT" class="us-instance grElement" style="height:40px;">\
	                    <div><a id="name" class="editablefield Name">:' + this.options.name+ '</a></div></div></div>';
	  $("#" + this.parrent.euid).append(this.innerHtml);
	  this.element = $("#"  + this.euid);
	},
	_init: function () {
      if (this.options.height)
	    $('#' + this.euid)
	     .css('width', '100%').css('height', this.options.height);

     if (this.options.top_min)
	    $('#' + this.euid + "_Border")
	     .css('top', this.options.top_min);
	},
	addMethod: function(md) {
		this.options.methods = this.options.methods || new Array();
		this.options.methods.push(md + "()");
	},
    getAutocomplete: function() {
		$.log("objinst AUTOCOMPLETE:");
		$.log("methods" + this.options.methods);
        return this.options.methods;
	},
	getName: function() {
      this.options.name = "" + $("#" + this.euid + " .Name" ).html();
      return this.options.name;
	}
});

// Drag helper element
// It is part of objinstance but it
// is implemented as a separate element
// menu should be shared from objinstance
dm.base.diagram("es.llport", dm.es.element, {
	options: {
		nameTemplate: "LLPort",
		width: '15px',
		height: '40px',
	    droppable: true,
        resizable_h: 'n-ul,s-ul',
		axis: 'y',
		level: 0
	},
	_create: function() {
	  // HTML for class structure creation
      this.innerHtml = '<div id="' + this.euid + '" class="us-port us-element-resizable-area grElement">\
						</div>';
	  $("#" + this.parrent.euid).append(this.innerHtml);
	  this.element = $("#"  + this.euid);
	},
	_init: function() {
      $('#' + this.euid  + '_Border')
	     .css('width', this.options.width)
		 .css('height', this.options.height)
		 .css('left', this.options.left)
		 .css('top', this.options.top);
	  if (this.options["z-index"])
	    this._setOption("z-index", this.options["z-index"]);
	},
    _setOption3: function( key, value ) {
        this.options[ key ] = value;
        if (key == "color") {
			$("#" + this.euid).css("background-color", value);
			return true;
		} else if (key == "borderwidth") {
		  $("#" + this.euid).css("border-width", value);
			return true;
		} else if (key == "font-family") {
		  $.log("ff: " + value);
		  $("#" + this.euid).css(key, value);
		  return true;
		} else if (key == "selected") {
		  if (value)
		   $('#' + this.euid +'_Border ' + ".ui-resizable-handle").css({'visibility':'visible'});
		  else
		   $('#' + this.euid +'_Border ' + ".ui-resizable-handle").css({'visibility':'hidden'});
		} else if (key == "z-index") {
		  $("#" + this.euid + '_Border ').css(key, value);
		}

        return this;
    }
});

dm.base.diagram("es.lldel", dm.es.element, {
	options: {
		nameTemplate: "LLdel",
		width: '15px',
		height: '15px',
	    droppable: true,
		axis: 'y'
	},
	_create: function() {
	  // HTML for class structure creation
      this.innerHtml = '<img id="' + this.euid + '" class="us-element-resizable-area" src="images/lldel.png">\
						</img>';
	  $("#" + this.parrent.euid).append(this.innerHtml);
	  this.element = $("#"  + this.euid);
	},
	_init: function() {
      $('#' + this.euid  + '_Border')
	     .css('width', this.options.width)
		 .css('height', this.options.height)
		 .css('left', this.options.left)
		 .css('top', this.options.top);
	  if (this.options["z-index"])
	    this._setOption("z-index", this.options["z-index"]);
	}
});

}) ( jQuery );
/*
Class: generalization

Generalization connector creates a connection beween two elements of diagram

Author:
  Evgeny Alexeyev (evgeny.alexeyev@googlemail.com)

Copyright:
  Copyright (c) 2011 Evgeny Alexeyev (evgeny.alexeyev@googlemail.com). All rights reserved.

URL:
  umlsync.org/about

Version:
  2.0.0 (2012-07-12)
*/
//@aspect
(function($, dm, undefined) {

dm.base.diagram("cs.llsequence", dm.cs.connector, {
    'draw': function(c, points, color) {
            if ((points == null) || (points.length < 2)) {
               return;
            }

            var ep = points.length-1;
            var x2 = points[ep][0],
            x1 = points[ep-1][0],
            y2 = points[ep][1],
            y1 = points[ep-1][1];

            var x = 10,
                dx = x2 -x1,
                dy = y2 -y1,
                gip = Math.sqrt(dx*dx + dy*dy);

            if (gip<x) {
               return;
            }

            var sina = dy/gip,
            cosa = dx/gip,
            x3 = x2 - Math.sqrt(x*x*3/4)*cosa,
            y3 = y2 - Math.sqrt(x*x*3/4)*sina,
            x6 = x1 - Math.sqrt(x*x*3)*cosa,
            y6 = y1 - Math.sqrt(x*x*3)*sina,
            x4 = x3 + x * sina/2,
            y4 = y3 - x * cosa/2,
            x5 = x3 - x * sina/2,
            y5 = y3 + x * cosa/2;
            
            c.beginPath();
            c.fillStyle = color;
            c.strokeStyle = color;
            c.moveTo(points[0][0], points[0][1]);
            for (i=1; i<ep; ++i) {
              c.lineTo(points[i][0], points[i][1]);
            }
            c.moveTo(x1, y1);
            c.lineTo(x3, y3);
            c.lineTo(x4, y4);
            c.lineTo(x2, y2);
            c.lineTo(x5, y5);
            c.lineTo(x3, y3);
            /*if ((this.epoints != undefined) && (this.epoints.length >0)) {
              for (i=0; i<this.epoints.length;++i)
              c.arc(this.epoints[i][0], this.epoints[i][1], 3, 0, Math.PI * 2, true);
            }*/
            c.stroke();
            c.closePath();            
    },
	_init: function() {
	  this.cleanOnNextTransform = true;
	},
    '_getConnectionPoints': function(fromId, toId, epoints) {
       var p1 = $('#'+ fromId).position();
       
       var p2 = $('#' + toId).position();
       
       var p11 = $('#'+ fromId + "_Border").position();
       var p21 = $('#' + toId + "_Border").position(),
       w11 = $('#' + fromId + "_Border").width() + 26,
       w21 = $('#' + toId + "_Border").width() + 26,
       scrollTop = 0,//$("#" + this.parrent.euid).scrollTop(),
       scrollLeft = $("#" + this.parrent.euid).scrollLeft();
    
     if (toId == "ConnectionHelper") {
       var y1 = (p11.top + 40 > p21.top) ? p11.top + 40 : p21.top;
       y1+=5;
       var y2 = y1;
       var x1 = (p11.left + w11/2 + 13);
       var x2 = (p21.left + 10);
       var newpoints = [[x1,y1], [x2,y2]];
       return newpoints;
     } else {
       if ((epoints == undefined) || (epoints.length ==0)) {
         var y1 = (p11.top > p21.top) ? p11.top : p21.top;
             h1 = (p11.top > p21.top) ? p1.top : p2.top;
           y1 += h1;
           var y2 = y1,
               x1 = 0,
               x2 = 0;
           if (p21.left > p11.left) {
             x1 = (p11.left + w11 - 20);
             x2 = (p21.left);
           } else {
             x1 = (p11.left + 10 );
             x2 = (p21.left + w21 - 20);
           }
           var newpoints = [[x1,y1+5], [x2,y2+5]];
         return newpoints;
       } else {
           var y2 = epoints[epoints.length-1][1],
             y1 = y2,
              x1 = 0,
             x2 = 0;
           if (p21.left > p11.left) {
             x1 = (p11.left + w11 - 20);
             x2 = (p21.left);
           } else {
             x1 = (p11.left + 10 );
             x2 = (p21.left + w21 - 20);
           }
           var newpoints = //[[x1,y1], [x2,y2]];
             [[x1 + scrollLeft,y1 + scrollTop], [x2 + scrollLeft,y2 + scrollTop]];
           return newpoints;
       }
     }
    },
    '_updateEPoints': function(ui) {
	  if (this.epoints && this.epoints.legth > 0)
        this.epoints = [[ui.position.left, ui.position.top]];
	  else 
	    this.epoints = [[ui.position.left, ui.position.top+5]]; // LLPort should be created on the same ui position threfore we have to shift extra point. But it is required for a first time only !!!
      this.cleanOnNextTransform = true;
      this.eppos = 0; // extra point position. Uses for temporary points which should be removed on next transform.
      this.parrent.draw();
    },
    'addLabel': function(opt) {
      var self = this;
      this.labels.push($("<div style='position:absolute;z-index:99999;'>" + opt.text + "</div>").appendTo("#" + this.parrent.euid)
      .css("left", opt.left)
      .css("top", opt.top));
    },
    'canRemovePoint': function() {
        return true;
    }
    });
//@aspect
})(jQuery, dm);
/**
  *  
  */
//@aspect
(function( $, dm, undefined ) {

dm.base.diagram("es.interface", dm.es.element, {
    'options': {
        'nameTemplate': "Interface",
        'width':'30px',
        'height':'30px'
    },
    '_update': function() {
       var p = $("#" + this.euid + "_Border").position();
       this.options.pageX = p.left;
       this.options.pageY = p.top;
       this.options.width = $("#" + this.euid + "_Border").width();
       this.options.height = $("#" + this.euid + "_Border").height();

	   p = $("#" + this.euid + " #name" ).position();
	   this.options.nameX = p.left;
	   this.options.nameY = p.top;
       
    },
    '_create': function() {
      this.innerHtml = '<div id="' + this.euid + '" style="width:100%;height:100%;">\
                        <div id="Circle" class="us-interface grElement"></div>\
                        </div>';
      $("#" + this.parrent.euid).append(this.innerHtml);
      this.element = $("#"  + this.euid);
    },
    '_init': function() {
      this.options.width = this.options.height;
      $('#' + this.euid  + '_Border')
         .css('width', this.options.width)
         .css('height', this.options.height);

      $('#' + this.euid + " #Circle")
         .css('width', this.options.width)
         .css('height', this.options.height);

	 if (this.options["background-color"]) {
	   $('#' + this.euid + " #Circle")
         .css('background-color', this.options["background-color"]);
	  }

      $('#' + this.euid + "_Border").bind( "resize", "#" + this.euid, function(event, ui) {
         var w = $(event.data).width(),
             h = $(event.data).height();
         var m = w;
         if (w > h)
            m = h;
         $(event.data).children(".us-interface").width(m).height(m);

      });

	  if (this.options['left']) {
        $('#' + this.euid + "_Border").css("left", this.options['left']);
      }

      if (this.options['top'])
        $('#' + this.euid + "_Border").css('top', this.options['top']);
	  
      if (this.options.name) {
	      var self = this;
          $("<div id='name' style='position:absolute;top:100%;z-index:99999;top:"+this.options.nameY+"px;left:"+this.options.nameX+"px;'>" + this.options.name + "</div>")
		  .appendTo("#" + this.euid);
      }
    },
    _setOption2: function(key, value) {
       return false;
    }
});

//@aspect
})(jQuery, dm);
